"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _webpack = require("next/dist/compiled/webpack/webpack");
var _constants = require("../../../shared/lib/constants");
var _utils = require("../loaders/utils");
var _path = require("path");
var _buildManifestPlugin = require("./build-manifest-plugin");
const PLUGIN_NAME = "FlightManifestPlugin";
class FlightManifestPlugin {
    dev = false;
    appDir = false;
    constructor(options){
        if (typeof options.dev === "boolean") {
            this.dev = options.dev;
        }
        this.appDir = options.appDir;
        this.pageExtensions = options.pageExtensions;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory  })=>{
            compilation.dependencyFactories.set(_webpack.webpack.dependencies.ModuleDependency, normalModuleFactory);
            compilation.dependencyTemplates.set(_webpack.webpack.dependencies.ModuleDependency, new _webpack.webpack.dependencies.NullDependency.Template());
        });
        compiler.hooks.make.tap(PLUGIN_NAME, (compilation)=>{
            compilation.hooks.processAssets.tap({
                name: PLUGIN_NAME,
                // @ts-ignore TODO: Remove ignore when webpack 5 is stable
                stage: _webpack.webpack.Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
            }, (assets)=>this.createAsset(assets, compilation, compiler.context));
        });
    }
    createAsset(assets, compilation, context) {
        const manifest = {};
        const appDir = this.appDir;
        const dev = this.dev;
        compilation.chunkGroups.forEach((chunkGroup)=>{
            function recordModule(chunk, id, mod) {
                const resource = mod.resource;
                // TODO: Hook into deps instead of the target module.
                // That way we know by the type of dep whether to include.
                // It also resolves conflicts when the same module is in multiple chunks.
                if (!resource || !_utils.clientComponentRegex.test(resource)) {
                    return;
                }
                const moduleExports = manifest[resource] || {};
                const moduleIdMapping = manifest.__ssr_module_mapping__ || {};
                moduleIdMapping[id] = moduleIdMapping[id] || {};
                // Note that this isn't that reliable as webpack is still possible to assign
                // additional queries to make sure there's no conflict even using the `named`
                // module ID strategy.
                let ssrNamedModuleId = (0, _path).relative(context, mod.resourceResolveData.path);
                if (!ssrNamedModuleId.startsWith(".")) ssrNamedModuleId = `./${ssrNamedModuleId}`;
                const exportsInfo = compilation.moduleGraph.getExportsInfo(mod);
                const cjsExports = [
                    ...new Set([].concat(mod.dependencies.map((dep)=>{
                        // Match CommonJsSelfReferenceDependency
                        if (dep.type === "cjs self exports reference") {
                            // `module.exports = ...`
                            if (dep.base === "module.exports") {
                                return "default";
                            }
                            // `exports.foo = ...`, `exports.default = ...`
                            if (dep.base === "exports") {
                                return dep.names.filter((name)=>name !== "__esModule");
                            }
                        }
                        return null;
                    }))), 
                ];
                const moduleExportedKeys = [
                    "",
                    "*"
                ].concat([
                    ...exportsInfo.exports
                ].filter((exportInfo)=>exportInfo.provided).map((exportInfo)=>exportInfo.name), ...cjsExports).filter((name)=>name !== null);
                // Get all CSS files imported in that chunk.
                const cssChunks = [];
                for (const entrypoint of chunk.groupsIterable){
                    const files = (0, _buildManifestPlugin).getEntrypointFiles(entrypoint);
                    for (const file of files){
                        if (file.endsWith(".css")) {
                            cssChunks.push(file);
                        }
                    }
                }
                moduleExportedKeys.forEach((name)=>{
                    let requiredChunks = [];
                    if (!moduleExports[name]) {
                        const isRelatedChunk = (c)=>{
                            var // If current chunk is a page, it should require the related page chunk;
                            // If current chunk is a component, it should filter out the related page chunk;
                            ref, ref1;
                            return ((ref = chunk.name) == null ? void 0 : ref.startsWith("pages/")) || !((ref1 = c.name) == null ? void 0 : ref1.startsWith("pages/"));
                        };
                        if (appDir) {
                            requiredChunks = chunkGroup.chunks.filter(isRelatedChunk).map((requiredChunk)=>{
                                return requiredChunk.id + ":" + (requiredChunk.name || requiredChunk.id) + (dev ? "" : "-" + requiredChunk.hash);
                            });
                        }
                        moduleExports[name] = {
                            id,
                            name,
                            chunks: requiredChunks.concat(cssChunks)
                        };
                    }
                    if (!moduleIdMapping[id][name]) {
                        moduleIdMapping[id][name] = {
                            ...moduleExports[name],
                            id: ssrNamedModuleId
                        };
                    }
                });
                manifest[resource] = moduleExports;
                manifest.__ssr_module_mapping__ = moduleIdMapping;
            }
            chunkGroup.chunks.forEach((chunk)=>{
                const chunkModules = compilation.chunkGraph.getChunkModulesIterable(chunk);
                for (const mod of chunkModules){
                    const modId = compilation.chunkGraph.getModuleId(mod);
                    recordModule(chunk, modId, mod);
                    // If this is a concatenation, register each child to the parent ID.
                    const anyModule = mod;
                    if (anyModule.modules) {
                        anyModule.modules.forEach((concatenatedMod)=>{
                            recordModule(chunk, modId, concatenatedMod);
                        });
                    }
                }
            });
        });
        const file1 = "server/" + _constants.FLIGHT_MANIFEST;
        const json = JSON.stringify(manifest);
        assets[file1 + ".js"] = new _webpack.sources.RawSource("self.__RSC_MANIFEST=" + json);
        assets[file1 + ".json"] = new _webpack.sources.RawSource(json);
    }
}
exports.FlightManifestPlugin = FlightManifestPlugin;

//# sourceMappingURL=flight-manifest-plugin.js.map